<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dashboard — Upload1</title>

<!-- Estilos minimalistas (dark) -->
<style>
  :root{
    --bg:#0f1420; --panel:#121a28; --muted:#9db2cf; --text:#eaf2ff; --accent:#4ea1ff;
    --good:#1fb978; --warn:#f0b429; --bad:#ff5d5d; --chip:#1b2435;
    --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    --sans: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans)}
  .wrap{max-width:1200px;margin:36px auto;padding:0 20px}
  h1{font-size:34px;margin:0 0 20px 0}
  .row{display:grid;grid-template-columns:1fr;gap:14px}
  @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
  .card{background:var(--panel);border:1px solid #243049;border-radius:14px;padding:14px 16px}
  .bar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{background:#1b2640;border:1px solid #2a3a5a;color:var(--text);padding:10px 14px;border-radius:10px;cursor:pointer}
  .btn.primary{background:var(--accent);border-color:#2f79ff;color:#00122c;font-weight:600}
  .btn.ghost{background:#121a28;border-color:#34415a}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  .pill{display:inline-flex;align-items:center;gap:6px;background:var(--chip);color:var(--muted);padding:6px 10px;border-radius:999px;font-size:12px}
  .ok{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .mono{font-family:var(--mono);white-space:pre-wrap;word-break:break-word;font-size:12.5px;line-height:1.45}
  .title{font-size:13px;color:var(--muted);margin:0 0 6px 0}
  .hl{color:#b6cffd}
  .muted{color:var(--muted)}
  input[type="file"]{display:none}
  .filelabel{padding:10px 14px;border:1px dashed #345;border-radius:10px;background:#0f1727;cursor:pointer}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:14px}
  .help li{margin:6px 0}
  .badge{padding:4px 8px;border-radius:6px;background:#0d1a2e;border:1px solid #26344e;color:#cfe1ff;font-size:12px}
  .counts{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
</style>
</head>
<body>
<div class="wrap">
  <h1>Dashboard</h1>

  <!-- Barra de ações -->
  <div class="card">
    <div class="bar">
      <span class="badge">.csv</span>
      <span class="muted">/</span>
      <span class="badge">.xlsx / .xls</span>
      <span class="muted">(Excel serial, <span class="hl">dd/mm/aaaa</span> ou <span class="hl">yyyy-mm-dd</span>. Se vier <b>data+hora</b>, extraímos a hora automaticamente.)</span>

      <label class="filelabel" for="fileInput">Escolher arquivo</label>
      <input id="fileInput" type="file" accept=".csv,.xlsx,.xls" />

      <button id="btnSave" class="btn primary" disabled>Salvar no banco</button>
      <button id="btnClear" class="btn ghost">Limpar UI</button>
    </div>

    <div id="libMsg" class="muted" style="margin-top:10px;"></div>

    <div class="counts">
      <span class="pill">Linhas <span id="countTotal" class="hl">0</span></span>
      <span class="pill">Válidas <span id="countValid" class="ok">0</span></span>
      <span class="pill">Puladas (sem data) <span id="countSkip" class="warn">0</span></span>
    </div>
  </div>

  <!-- Prévia / Mapeamento -->
  <div class="grid2">
    <div class="card">
      <div class="title">Prévia (5 primeiras linhas válidas):</div>
      <div id="preview" class="mono muted">—</div>
    </div>

    <div class="card">
      <div class="title">Mapeamento escolhido:</div>
      <div id="mapping" class="mono muted">—</div>
    </div>
  </div>

  <!-- Ajuda -->
  <div class="card help" style="margin-top:14px">
    <div class="title">Ajuda rápida</div>
    <ul class="muted">
      <li>Se aparecer <code>"null value in column <b>dia</b>"</code>, alguma linha veio sem data. Eu pulo essas linhas no upload.</li>
      <li>Datas aceitas: Excel serial, <b>dd/mm/aaaa</b> ou <b>yyyy-mm-dd</b>. Se vier data+hora, eu extraio a <b>hora</b> automaticamente.</li>
      <li>Para ler Excel **offline**, deixe o arquivo <code>xlsx.full.min.js</code> **na MESMA pasta** deste HTML (sem CDN).</li>
    </ul>
  </div>
</div>

<!-- SheetJS offline (se o arquivo estiver ao lado do HTML, será carregado) -->
<script>
(function ensureSheetJS(){
  function show(msg, cls=""){ const el=document.getElementById('libMsg'); el.innerHTML = msg; el.className=cls }
  function inject(src, onload, onerror){
    const s=document.createElement('script'); s.src=src; s.onload=onload; s.onerror=onerror; document.head.appendChild(s);
  }
  // tenta carregar local
  inject('xlsx.full.min.js', 
    ()=>show('Leitor Excel: <b class="ok">OK</b> (xlsx.full.min.js local).'),
    ()=>show('Arquivo Excel selecionado, mas a biblioteca <b>XLSX</b> não foi encontrada localmente. '
            +'Para usar Excel offline, coloque <code>xlsx.full.min.js</code> na mesma pasta. '
            +'Enquanto isso, use <b>CSV</b>.', 'warn') );
})();
</script>

<script>
/* =========================  CONFIG SUPABASE  ========================= */
const SUPABASE_URL  = "https://uahmcfzerofhzjvlzrqc.supabase.co";
const SUPABASE_KEY  = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVhaG1jZnplcm9maHpqdmx6cnFjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxNTg2MzQsImV4cCI6MjA3MDczNDYzNH0.lPVr3wmrXAmSMY5j7JFy6mI87T3I2TxhVKV-gLc7_VU";
const REST_TABLE     = "vendas_xlsx";         // tabela de destino
const INSERT_CHUNK   = 500;                    // lote de insert

/* =========================  UI ELEMENTS  ========================= */
const $file    = document.getElementById('fileInput');
const $prev    = document.getElementById('preview');
const $map     = document.getElementById('mapping');
const $btnSave = document.getElementById('btnSave');
const $btnClr  = document.getElementById('btnClear');
const $ctAll   = document.getElementById('countTotal');
const $ctVal   = document.getElementById('countValid');
const $ctSkip  = document.getElementById('countSkip');

/* =========================  STATE  ========================= */
let parsedRows = [];   // linhas normalizadas (prontas p/ gravar)
let mapping    = {};   // colunas escolhidas para cada campo
let rawTotal   = 0;    // linhas totais lidas
let skipped    = 0;    // sem data

/* =========================  HELPERS  ========================= */
const normStr = s => (s ?? "").toString().trim();
const toInt = v => {
  if (v == null || v === "") return null;
  const n = parseInt(String(v).replace(/\D+/g,''), 10);
  return Number.isFinite(n) ? n : null;
};
const toNum = v => {
  if (v == null || v === "") return null;
  if (v instanceof Date) return v.getTime(); // não deve acontecer, mas…
  // troca vírgula por ponto e remove milhar
  const s = String(v).replace(/\./g,'').replace(',','.');
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
};
// Excel serial -> Date
function fromExcelSerial(n){
  const d = new Date(Date.UTC(1899, 11, 30)); // origem Excel (corrigido)
  d.setUTCDate(d.getUTCDate() + Number(n));
  return d;
}
// Parse de datas possíveis
function parseDia(val){
  if (val == null || val === "") return null;
  if (val instanceof Date) return new Date(val.getFullYear(), val.getMonth(), val.getDate());
  if (!isNaN(val)) { const d = fromExcelSerial(val); return new Date(d.getFullYear(),d.getMonth(),d.getDate()); }
  const s = normStr(val);

  // yyyy-mm-dd hh:mm[:ss]
  let m = s.match(/^(\d{4})-(\d{2})-(\d{2})(?:[ T](\d{2}):(\d{2})(?::\d{2})?)?$/);
  if (m) return new Date(+m[1], +m[2]-1, +m[3]);

  // dd/mm/aaaa [hh:mm]
  m = s.match(/^(\d{2})[\/\-](\d{2})[\/\-](\d{4})(?:[ T](\d{2}):(\d{2}))?$/);
  if (m) return new Date(+m[3], +m[2]-1, +m[1]);

  // dd-mm-aaaa
  m = s.match(/^(\d{2})-(\d{2})-(\d{4})$/);
  if (m) return new Date(+m[3], +m[2]-1, +m[1]);

  // yyyy/mm/dd
  m = s.match(/^(\d{4})[\/\-](\d{2})[\/\-](\d{2})$/);
  if (m) return new Date(+m[1], +m[2]-1, +m[3]);

  return null;
}
function parseHora(val, possibleDateTime){
  // prioridade: hora explícita
  if (val != null && val !== "") {
    if (val instanceof Date) return val.getHours();
    const s = normStr(val);
    // "11", "11:00", "23:59"
    let m = s.match(/^(\d{1,2})(?::\d{2})?$/);
    if (m) { const h=+m[1]; return (h>=0 && h<=23) ? h : null; }
    if (!isNaN(val)) { const n = Number(val); if (n>=0 && n<=23) return n; }
  }
  // senão, tenta extrair da data+hora
  if (possibleDateTime instanceof Date) return possibleDateTime.getHours();
  if (typeof possibleDateTime === 'number'){ return fromExcelSerial(possibleDateTime).getHours(); }
  const s = normStr(possibleDateTime);
  const m = s.match(/(\d{2}):(\d{2})(?::\d{2})?$/);
  if (m) { const h=+m[1]; return (h>=0 && h<=23) ? h : null; }
  return null;
}
function turnoFromHora(h){
  if (h == null) return null;
  if (h < 11) return "Manhã";
  if (h < 18) return "Dia";
  return "Noite";
}

function choose(headers, aliases){
  // retorna o primeiro header que case com qualquer alias
  const low = headers.map(h=>h.toLowerCase());
  for (const a of aliases){
    const i = low.indexOf(a.toLowerCase());
    if (i>=0) return headers[i];
  }
  return null;
}

function detectMapping(headers){
  // sinônimos
  const m = {};
  m.dia   = choose(headers, ["Data da venda","Data do pedido","Data","Dia","Data hora venda","Datahora","data_venda","Data do pedido"]);
  m.horaK = choose(headers, ["Hora","Horário","Horario","time","hora_venda"]);
  m.unid  = choose(headers, ["unidade","Uni","Unid","Empresa","Filial","cod_unidade"]);
  m.loja  = choose(headers, ["Nome da loja","Loja","Loja Nome","Fantasia","Código da loja","Codigo da loja"]);
  m.canal = choose(headers, ["Canal de venda","Canal","Origem","Canal de vendas"]);
  m.pag   = choose(headers, ["Pagamento","Tipo de Pagamento","Pagamento base","pagamento_base"]);
  m.canc  = choose(headers, ["Está cancelado","Cancelado","Cancelada","is_cancel"]);
  m.ped   = choose(headers, ["Itens","Pedidos","Qtd","Qtde","qtd_pedidos"]);
  m.fat   = choose(headers, ["FAT","Faturamento","Valor Entregador","valor_total","fat"]);
  m.des   = choose(headers, ["DES","Desconto","des"]);
  m.fre   = choose(headers, ["FRE","Entrega","Frete","fre"]);
  m.pid   = choose(headers, ["pedido_id","Pedido","Order ID","id_pedido"]);

  return m;
}

function stringifyMapping(m){
  const lines = [
    `{`,
    `  "dia": "${m.dia ?? '—'}",`,
    `  "hora": "${m.horaK ? 'derivada/ausente' : 'derivada/ausente'}",`,
    `  "unid": "${m.unid ?? '—'}",`,
    `  "loja": "${m.loja ?? '—'}",`,
    `  "canal":"${m.canal ?? '—'}",`,
    `  "pag":  "${m.pag ?? '—'}",`,
    `  "canc": "${m.canc ?? '—'}",`,
    `  "ped":  "${m.ped ?? '—'}",`,
    `  "fat":  "${m.fat ?? '—'}",`,
    `  "des":  "${m.des ?? '—'}",`,
    `  "fre":  "${m.fre ?? '—'}",`,
    `  "pedido_id": "${m.pid ?? '(opcional/ausente)'}"`,
    `}`
  ];
  return lines.join("\n");
}

/* =========================  PARSE  ========================= */
async function handleFile(file){
  $btnSave.disabled = true;
  $prev.textContent = "Lendo arquivo…";
  $map.textContent  = "—";
  parsedRows = [];
  mapping    = {};
  rawTotal   = 0; skipped = 0;
  refreshCounts();

  const isExcel = /\.(xlsx|xls)$/i.test(file.name);
  const isCSV   = /\.csv$/i.test(file.name);

  let rows = [];

  if (isExcel) {
    if (!(window.XLSX && XLSX.read)) {
      $prev.innerHTML = "Arquivo Excel selecionado, mas <b>XLSX</b> não está disponível. "
        + "Coloque <code>xlsx.full.min.js</code> na mesma pasta, ou exporte seu arquivo para <b>CSV</b>.";
      return;
    }
    const buf = await file.arrayBuffer();
    const wb  = XLSX.read(buf, {type:"array", cellDates:true, dateNF:'yyyy-mm-dd'});
    const ws  = wb.Sheets[wb.SheetNames[0]];
    rows = XLSX.utils.sheet_to_json(ws, {defval:null});
  } else if (isCSV) {
    // CSV via SheetJS (se xlsx.full.min.js existir) — senão usa parser simples
    if (window.XLSX && XLSX.read) {
      const txt = await file.text();
      const wb  = XLSX.read(txt, {type:'string'});
      const ws  = wb.Sheets[wb.SheetNames[0]];
      rows = XLSX.utils.sheet_to_json(ws, {defval:null});
    } else {
      rows = await parseCSVPlain(await file.text());
    }
  } else {
    $prev.textContent = "Formato não suportado. Use .xlsx/.xls/.csv";
    return;
  }

  rawTotal = rows.length;

  const headers = rows[0] ? Object.keys(rows[0]) : [];
  mapping = detectMapping(headers);
  $map.textContent = stringifyMapping(mapping);

  // Normalização
  parsedRows = [];
  skipped    = 0;

  for (const r of rows){
    const src_d = r[mapping.dia];
    const src_h = mapping.horaK ? r[mapping.horaK] : null;

    const dia  = parseDia(src_d);
    if (!dia){ skipped++; continue; }

    const hora = parseHora(src_h, src_d);
    const unid = normStr(r[mapping.unid]);
    const loja = normStr(r[mapping.loja]);
    const canal= normStr(r[mapping.canal]);
    const pag  = normStr(r[mapping.pag]);

    let canc   = normStr(r[mapping.canc]).toLowerCase();
    if (canc === "true" || canc === "sim" || canc === "yes") canc = "Sim";
    else if (canc === "não" || canc === "nao" || canc === "false" || canc === "no") canc = "Não";
    else if (!canc) canc = "Não";

    const pedidos = toInt(r[mapping.ped]) ?? 1;
    const fat  = toNum(r[mapping.fat]);
    const des  = toNum(r[mapping.des]);
    const fre  = toNum(r[mapping.fre]);
    const pid  = normStr(r[mapping.pid]) || null;

    const turno = turnoFromHora(hora);

    parsedRows.push({
      dia: dia.toISOString().slice(0,10),
      hora: hora,
      unidade: unid || null,
      loja: loja || null,
      canal: canal || null,
      pagamento_base: pag || null,
      cancelado: canc,
      pedidos: pedidos,
      fat: fat,
      des: des,
      fre: fre,
      pedido_id: pid,
      turno: turno
      // created_at: server default
    });
  }

  // Prévia
  $prev.textContent = (parsedRows.slice(0,5).map(j => JSON.stringify(j,null,2)).join("\n_\n")) || "—";

  refreshCounts();
  $btnSave.disabled = parsedRows.length === 0;
}

function refreshCounts(){
  $ctAll.textContent  = String(rawTotal);
  $ctVal.textContent  = String(parsedRows.length);
  $ctSkip.textContent = String(skipped);
}

/* Parser CSV simples (fallback) */
async function parseCSVPlain(text){
  // separador ; ou , (auto)
  const sep = text.indexOf(';')>-1 && text.indexOf(',')>-1 ? (text.split('\n')[0].split(';').length > text.split('\n')[0].split(',').length ? ';' : ',')
            : (text.indexOf(';')>-1 ? ';' : ',');
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return [];
  const headers = lines[0].split(sep).map(s=>s.trim());
  const out = [];
  for (let i=1;i<lines.length;i++){
    const cols = lines[i].split(sep);
    const row = {};
    headers.forEach((h,idx)=> row[h]= cols[idx] ?? null);
    out.push(row);
  }
  return out;
}

/* =========================  SAVE TO SUPABASE  ========================= */
async function saveToSupabase(){
  if (!parsedRows.length) return;
  $btnSave.disabled = true;
  $btnSave.textContent = "Salvando…";

  const url = `${SUPABASE_URL}/rest/v1/${REST_TABLE}`;
  const headers = {
    "apikey": SUPABASE_KEY,
    "Authorization": `Bearer ${SUPABASE_KEY}`,
    "Content-Type": "application/json",
    "Prefer": "return=representation"
  };

  let ok = 0, fail = 0, lastErr=null;

  for (let i=0;i<parsedRows.length;i+=INSERT_CHUNK){
    const chunk = parsedRows.slice(i, i+INSERT_CHUNK);
    try{
      const rsp = await fetch(url, {method:"POST", headers, body: JSON.stringify(chunk) });
      if (!rsp.ok){
        const msg = await rsp.text();
        fail += chunk.length; lastErr = msg;
      }else{
        const arr = await rsp.json();
        ok += arr.length;
      }
    }catch(e){
      fail += chunk.length; lastErr = e.message;
    }
  }

  if (fail===0){
    alert(`✅ Envio concluído!\nRegistros inseridos: ${ok}.`);
  }else{
    alert(`⚠️ Parte dos registros falhou.\nInseridos: ${ok}\nFalhas: ${fail}\nÚltimo erro:\n${lastErr}`);
  }

  $btnSave.textContent = "Salvar no banco";
  $btnSave.disabled = false;
}

/* =========================  EVENTS  ========================= */
$file.addEventListener('change', (ev)=>{
  const f = ev.target.files?.[0];
  if (!f) return;
  handleFile(f);
});
$btnSave.addEventListener('click', saveToSupabase);
$btnClr.addEventListener('click', ()=>{
  $file.value = "";
  parsedRows = []; mapping={}; rawTotal=0; skipped=0;
  refreshCounts();
  $prev.textContent = "—";
  $map.textContent  = "—";
  $btnSave.disabled = true;
});
</script>
</body>
</html>
