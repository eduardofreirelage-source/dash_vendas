<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dashboard – Upload de Vendas (sem CDN)</title>
<style>
  :root{--bg:#0b1020;--card:#121830;--mut:#7a88a8;--ok:#29c58a;--warn:#ffcc00;--err:#ff6b6b}
  *{box-sizing:border-box}
  body{margin:0;background:#0a0f1f;color:#e6edf5;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1100px;margin:28px auto;padding:0 16px}
  h1{margin:0 0 16px}
  .card{background:#121830;border:1px solid #24304d;border-radius:14px;padding:14px;margin:12px 0;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .col{flex:1 1 0}
  .btn{appearance:none;border:0;border-radius:10px;padding:10px 14px;background:#2b6ef3;color:#fff;cursor:pointer;font-weight:600}
  .btn.ghost{background:#1a223a}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .mini{font-size:12px;color:var(--mut)}
  pre{white-space:pre-wrap;word-break:break-word;background:#0d1428;border-radius:10px;padding:10px;max-height:260px;overflow:auto}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;margin-left:8px}
  .ok{background:#14372b;color:#86f1c3}
  .warn{background:#3a320e;color:#ffe28c}
  .err{background:#3a1515;color:#ffb3b3}
</style>
</head>
<body>
<div class="wrap">
  <h1>Dashboard</h1>

  <div class="card">
    <div class="row" style="align-items:center;justify-content:space-between;">
      <div class="col">
        <div class="mini">
          Upload <span class="pill warn">.csv</span> (recomendado, sem dependências) ou <span class="pill warn">.xlsx/.xls</span> <i>(se <code>xlsx.full.min.js</code> estiver na mesma pasta)</i>.
        </div>
      </div>
      <div>
        <input id="file" type="file" accept=".csv,.xlsx,.xls" />
        <button id="btnSave" class="btn" disabled>Salvar no banco</button>
        <button id="btnClear" class="btn ghost">Limpar UI</button>
      </div>
    </div>
    <div id="status" class="mini" style="margin-top:10px;">Pronto. Selecione um arquivo.</div>
  </div>

  <div class="row">
    <div class="card col">
      <div class="mini">Prévia (5 primeiras linhas válidas):</div>
      <pre id="preview">—</pre>
    </div>
    <div class="card col">
      <div class="mini">Mapeamento escolhido:</div>
      <pre id="mapping">—</pre>
    </div>
  </div>

  <div class="card">
    <div class="mini"><b>Ajuda rápida</b></div>
    <ul class="mini">
      <li>Se aparecer <code>“null value in column &quot;dia&quot;”</code>, alguma linha veio sem data. Eu pulo essas linhas.</li>
      <li>Datas aceitas: Excel serial, <b>dd/mm/aaaa</b> ou <b>yyyy-mm-dd</b>. Se vier data+hora, extraio a <b>hora</b> automaticamente.</li>
      <li>Para ler XLSX offline, coloque <code>xlsx.full.min.js</code> nesta pasta (mesmo nível do HTML).</li>
    </ul>
  </div>
</div>

<!-- Tenta carregar XLSX localmente; se não existir, ignora e funciona só com CSV -->
<script>
(function tryLoadLocalXLSX(){
  var s=document.createElement('script');
  s.src='./xlsx.full.min.js'; s.async=true;
  s.onload=()=>console.log('XLSX pronto (local).');
  s.onerror=()=>console.log('XLSX local não encontrado. CSV continuará funcionando.');
  document.head.appendChild(s);
})();
</script>

<script>
/* ====== CONFIGURAÇÃO SUPABASE (REST) ====== */
const SUPABASE_URL = 'https://uahmcfzerofhzjvlzrqc.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVhaG1jZnplcm9maHpqdmx6cnFjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxNTg2MzQsImV4cCI6MjA3MDczNDYzNH0.lPVr3wmrXAmSMY5j7JFy6mI87T3I2TxhVKV-gLc7_VU';
const TABLE_NAME = 'vendas_xlsx';   // destino do upload

/* ====== DOM ====== */
const elFile = document.getElementById('file');
const elSave = document.getElementById('btnSave');
const elClear = document.getElementById('btnClear');
const elPreview = document.getElementById('preview');
const elMapping = document.getElementById('mapping');
const elStatus = document.getElementById('status');

/* ====== STATE ====== */
let parsedRows = [];
let skipped = 0;

/* ====== UTILS ====== */
function setStatus(msg, tone=null){
  elStatus.textContent = msg;
  elStatus.classList.remove('ok','warn','err');
  if (tone) elStatus.classList.add(tone);
}
const pretty = (o)=>JSON.stringify(o,null,2);

const brToNum = (v) => {
  if (v == null || v === '') return null;
  if (typeof v === 'number') return v;
  let s = String(v).trim();
  s = s.replace(/R\$\s?/gi,'').replace(/\./g,'').replace(',', '.');
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
};
const toInt = (v) => {
  if (v == null || v === '') return null;
  if (typeof v === 'number') return Math.floor(v);
  const n = parseInt(String(v).replace(/\D+/g,''), 10);
  return Number.isFinite(n) ? n : null;
};
const excelSerialToDate = (serial) => {
  const utcDays  = Math.floor(serial - 25569);
  const date = new Date(utcDays * 86400 * 1000);
  const frac = serial - Math.floor(serial) + 1e-8;
  const secs = Math.floor(frac * 86400);
  return { date, hour: Math.floor(secs/3600) };
};
const parseDateLike = (raw) => {
  if (raw == null || raw === '') return { day:null, hour:null };
  if (typeof raw === 'number') {
    const {date, hour} = excelSerialToDate(raw);
    const y = date.getUTCFullYear(), m = String(date.getUTCMonth()+1).padStart(2,'0'), d = String(date.getUTCDate()).padStart(2,'0');
    return { day:`${y}-${m}-${d}`, hour };
  }
  let s = String(raw).trim();
  const iso = Date.parse(s);
  if (!Number.isNaN(iso)) {
    const dt = new Date(iso);
    const y = dt.getFullYear(), m = String(dt.getMonth()+1).padStart(2,'0'), d = String(dt.getDate()).padStart(2,'0');
    return { day:`${y}-${m}-${d}`, hour: dt.getHours() };
  }
  const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})(?:\s+(\d{1,2})(?::(\d{1,2}))?)?$/);
  if (m) {
    const d = String(m[1]).padStart(2,'0'), mo = String(m[2]).padStart(2,'0'); const y = m[3].length===2 ? ('20'+m[3]) : m[3];
    const h = m[4] ? parseInt(m[4],10) : null;
    return { day:`${y}-${mo}-${d}`, hour:h };
  }
  return { day:null, hour:null };
};
const normCancel = (v) => {
  const s=(v??'').toString().trim().toLowerCase();
  if (['sim','s','y','yes','true','1'].includes(s)) return 'Sim';
  return 'Não';
};

/* ====== CSV PARSER (sem libs) ====== */
function detectDelimiter(sample) {
  const first = sample.split(/\r?\n/).find(l=>l.trim().length);
  if (!first) return ',';
  const counts = { ';': (first.match(/;/g)||[]).length, ',': (first.match(/,/g)||[]).length, '\t': (first.match(/\t/g)||[]).length };
  return Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0] || ',';
}
function parseCSV(text){
  const delim = detectDelimiter(text);
  const lines = text.replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n');
  if (!lines.length) return [];
  const out = [];
  const parseLine = (line) => {
    const res = []; let cur=''; let inQ=false;
    for (let i=0;i<line.length;i++){
      const ch=line[i];
      if (ch === '"'){
        if (inQ && line[i+1]==='"'){ cur+='"'; i++; }
        else inQ = !inQ;
      }else if (ch === delim && !inQ){ res.push(cur); cur=''; }
      else cur += ch;
    }
    res.push(cur);
    return res;
  };
  const header = parseLine(lines.shift()).map(h=>h.trim());
  for (const ln of lines){
    if (!ln.trim()) continue;
    const cols = parseLine(ln);
    const obj = {};
    header.forEach((h,idx)=> obj[h] = cols[idx] ?? '');
    out.push(obj);
  }
  return out;
}

/* ====== MAPEAMENTO ====== */
const pickKey = (obj, cands) => {
  const low=Object.fromEntries(Object.keys(obj).map(k=>[k.toLowerCase(),k]));
  for (const c of cands){
    if (c instanceof RegExp){ for (const k in low){ if (c.test(k)) return low[k]; } }
    else { if (low[c.toLowerCase()]) return low[c.toLowerCase()]; }
  }
  return null;
};
const buildMapping = (row) => ({
  dia : pickKey(row, [/^data.*venda/, /^data/, /^dt/, /^dia$/]),
  hora: pickKey(row, [/^hora/, /^hr/, /hour/, /hor[aá]rio/]),
  unid: pickKey(row, [/^unidade/, /^filial/, /^empresa/]),
  loja: pickKey(row, [/^loja/, /^nome.*loja/, /^c[oó]digo.*loja/]),
  canal: pickKey(row, [/^canal/, /^origem/, /^meio/]),
  pag: pickKey(row, [/^pagamento.*base/, /^pagamento/, /^forma.*pag/]),
  canc: pickKey(row, [/^cancelado/, /^est[aá].*cancel/]),
  ped: pickKey(row, [/^pedidos?$/, /^qtd.*(ped|itens)/, /^itens$/]),
  fat: pickKey(row, [/^fat(uramento)?/, /^valor.*(total|venda|nota|liquido)/]),
  des: pickKey(row, [/^des(conto)?$/, /^vl.*desconto/]),
  fre: pickKey(row, [/^(fre|entrega|frete)/, /^vl.*entrega/]),
});

/* ====== FILE HANDLING ====== */
elFile.addEventListener('change', async (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  parsedRows = []; skipped = 0;
  elPreview.textContent='—'; elMapping.textContent='—'; elSave.disabled=true;

  try{
    setStatus('Lendo arquivo…');

    // XLSX local?
    const isXLSX = /\.(xlsx|xls)$/i.test(f.name);
    if (isXLSX && !window.XLSX){
      setStatus('Arquivo Excel selecionado, mas a biblioteca XLSX não está disponível localmente. Exporte para CSV ou coloque xlsx.full.min.js na mesma pasta.', 'warn');
      return;
    }

    let rows = [];
    if (isXLSX){
      const data = await f.arrayBuffer();
      const wb = XLSX.read(data, { type:'array' });
      const ws = wb.Sheets[wb.SheetNames[0]];
      rows = XLSX.utils.sheet_to_json(ws, { raw:true });
    } else {
      const text = await f.text();
      rows = parseCSV(text);
    }

    if (!rows.length){ setStatus('Nenhuma linha encontrada.', 'warn'); return; }

    const map = buildMapping(rows[0]);

    for (const r of rows){
      let day=null,hour=null;
      if (map.dia && r[map.dia]!=null && r[map.dia]!==''){
        const d1 = parseDateLike(r[map.dia]); day=d1.day; hour=d1.hour;
      }
      if (!day && map.hora && r[map.hora] instanceof Date){
        const d=r[map.hora];
        const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), dd=String(d.getDate()).padStart(2,'0');
        day=`${y}-${m}-${dd}`; hour=d.getHours();
      }
      if (!day){ skipped++; continue; }

      const row = {
        dia: day,
        hora: hour ?? (map.hora ? toInt(r[map.hora]) : null),
        unidade: map.unid ? String(r[map.unid]??'').trim() : null,
        loja: map.loja ? String(r[map.loja]??'').trim() : null,
        canal: map.canal ? String(r[map.canal]??'').trim() : null,
        pagamento_base: map.pag ? String(r[map.pag]??'').trim() : null,
        cancelado: normCancel(map.canc ? r[map.canc] : 'Não'),
        pedidos: (map.ped ? toInt(r[map.ped]) : null) ?? 1,
        fat: brToNum(map.fat ? r[map.fat] : null) ?? 0,
        des: brToNum(map.des ? r[map.des] : null) ?? 0,
        fre: brToNum(map.fre ? r[map.fre] : null) ?? 0,
      };
      parsedRows.push(row);
    }

    elPreview.textContent = parsedRows.slice(0,5).map(pretty).join('\n—\n') || '—';
    elMapping.textContent = pretty(map);
    setStatus(`Linhas válidas: ${parsedRows.length} | Puladas (sem data): ${skipped}`, parsedRows.length ? 'ok' : 'warn');

    elSave.disabled = parsedRows.length === 0;

  }catch(err){
    console.error(err);
    setStatus('Erro ao ler arquivo: '+(err?.message||err), 'err');
  }
});

elClear.addEventListener('click', ()=>{
  elFile.value=''; parsedRows=[]; skipped=0;
  elPreview.textContent='—'; elMapping.textContent='—';
  elSave.disabled=true; setStatus('Limpo. Pronto para novo upload.');
});

/* ====== SAVE VIA REST (sem supabase-js) ====== */
async function saveBatch(batch){
  const url = `${SUPABASE_URL}/rest/v1/${encodeURIComponent(TABLE_NAME)}`;
  const res = await fetch(url,{
    method:'POST',
    headers:{
      'apikey': SUPABASE_ANON_KEY,
      'Authorization': 'Bearer '+SUPABASE_ANON_KEY,
      'Content-Type': 'application/json',
      'Prefer': 'return=minimal'
    },
    body: JSON.stringify(batch)
  });
  if (!res.ok){
    const txt = await res.text().catch(()=> '');
    throw new Error(`HTTP ${res.status} – ${txt}`);
  }
}

elSave.addEventListener('click', async ()=>{
  if (!parsedRows.length){ setStatus('Nada para salvar.', 'warn'); return; }
  elSave.disabled=true;

  try{
    let done=0; const BATCH=500;
    for (let i=0;i<parsedRows.length;i+=BATCH){
      const chunk = parsedRows.slice(i,i+BATCH);
      await saveBatch(chunk);
      done+=chunk.length;
      setStatus(`Gravando… ${done}/${parsedRows.length}`);
    }
    setStatus(`Concluído: ${parsedRows.length} inseridas.`, 'ok');
  }catch(err){
    console.error(err);
    setStatus('Falha ao salvar: '+(err?.message||err), 'err');
    elSave.disabled=false;
  }
});
</script>
</body>
</html>
