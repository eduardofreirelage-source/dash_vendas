<script>
// ================= HOTFIX: filtros sem espaços + init datas ================
async function reloadStaticOptions(){
  setStatus('Carregando filtros…');
  try{
    const pairs = [
      { col:'unidade',        ms: ms.unids },
      { col:'loja',           ms: ms.lojas },
      { col:'turno',          ms: ms.turnos },
      { col:'canal',          ms: ms.canais },
      { col:'pagamento_base', ms: ms.pags }
    ];

    for (const {col, ms:ctrl} of pairs){
      const { data, error } = await supa
        .from(READ_VIEW)
        .select(col)
        .not(col, 'is', null)
        .order(col, { ascending:true, nullsLast:true })
        .limit(10000);

      if (error) { console.warn('[filtros]', col, error); continue; }

      const opts = [...new Set(
        (data||[])
          .map(r => String(r[col] ?? '').trim())
          .filter(v => v.length)
      )];
      ctrl.setOptions(opts);
    }

    // Cancelado começa em "Não" por padrão
    ms.cancel.set(['Não']);
    setStatus('OK — filtros carregados','ok');
  }catch(e){
    console.error(e);
    setStatus('Erro ao carregar filtros','err');
  }
}

// Busca min/max de dia na view e inicia o período rápido (30 dias)
async function loadMinMaxAndInit(){
  try{
    const rMin = await supa.from(READ_VIEW).select('dia').order('dia', {ascending:true}).limit(1).maybeSingle();
    const rMax = await supa.from(READ_VIEW).select('dia').order('dia', {ascending:false}).limit(1).maybeSingle();
    firstDay = rMin?.data?.dia ?? iso(new Date());
    lastDay  = rMax?.data?.dia ?? iso(new Date());

    // aplica 30 dias (ou o que clicar nos chips)
    applyQuick('30');
  }catch(e){
    console.error(e);
    // fallback seguro
    firstDay = firstDay || iso(new Date());
    lastDay  = lastDay  || iso(new Date());
    applyQuick('30');
  }
}

// Fallback simples usado só quando pedimos cancelados direto da view
async function fetchRowsLocal(de,ate,onlyCancel){
  const q = supa.from(READ_VIEW)
    .select('pedidos,fat')
    .gte('dia', de).lte('dia', ate);

  const { data, error } = onlyCancel === 'Sim'
    ? await q.eq('cancelado','Sim')
    : await q.eq('cancelado','Não');

  if (error) { console.warn('[fetchRowsLocal]', error); return []; }
  return data || [];
}

// Orquestrador: KPIs + Gráficos sempre que
